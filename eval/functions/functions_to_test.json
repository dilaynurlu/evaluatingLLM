[
  {
    "name": "get_auth_from_url",
    "module": "requests.utils",
    "file": "requests/src/requests/utils.py",
    "qualname": "requests.utils.get_auth_from_url",
    "function_def": [
      "def get_auth_from_url(url):",
      "    \"\"\"Given a url with authentication components, extract them into a tuple of",
      "    username,password.",
      "",
      "    :rtype: (str,str)",
      "    \"\"\"",
      "    parsed = urlparse(url)",
      "",
      "    try:",
      "        auth = (unquote(parsed.username), unquote(parsed.password))",
      "    except (AttributeError, TypeError):",
      "        auth = (\"\", \"\")",
      "",
      "    return auth"
    ],
    "test_cases": [
      {
        "id": 1,
        "test_name": "test_get_auth_from_url",
        "test_file": "requests/tests/test_utils.py",
        "test_nodeid": "requests/tests/test_utils.py::test_get_auth_from_url",
        "test_code": [
          "USER = PASSWORD = \"%!*'();:@&=+$,/?#[] \"",
          "ENCODED_USER = compat.quote(USER, \"\")",
          "ENCODED_PASSWORD = compat.quote(PASSWORD, \"\")",
          "",
          "@pytest.mark.parametrize(",
          "    \"url, auth\",",
          "    (",
          "        (",
          "            f\"http://{ENCODED_USER}:{ENCODED_PASSWORD}@request.com/url.html#test\",",
          "            (USER, PASSWORD),",
          "        ),",
          "        (\"http://user:pass@complex.url.com/path?query=yes\", (\"user\", \"pass\")),",
          "        (\"http://user:pass%20pass@complex.url.com/path?query=yes\", (\"user\", \"pass pass\")),",
          "        (\"http://user:pass pass@complex.url.com/path?query=yes\", (\"user\", \"pass pass\")),",
          "        (\"http://user%25user:pass@complex.url.com/path?query=yes\", (\"user%user\", \"pass\")),",
          "        (\"http://user:pass%23pass@complex.url.com/path?query=yes\", (\"user\", \"pass#pass\")),",
          "        (\"http://complex.url.com/path?query=yes\", (\"\", \"\")),",
          "    ),",
          ")",
          "def test_get_auth_from_url(url, auth):",
          "    assert get_auth_from_url(url) == auth"
        ]
      }
    ],
    "fixtures": [],
    "description": "Extract username and password from a URL, decoding percent-encoded components. Returns ('', '') when no credentials present or when parsed attributes are missing.",
    "security_focus": [
      "credential_handling",
      "percent_encoding_handling",
      "sensitive_output_disclosure"
    ],
    "setup_notes": {
      "note": "Pure unit test; no network or heavy fixtures required. The test uses compat.quote to prepare encoded username/password examples. When sending to an LLM, include the parametrization examples so the model sees varied encoded and edge-case inputs."
    }
  },
  {
    "name": "prepend_scheme_if_needed",
    "module": "requests.utils",
    "file": "requests/src/requests/utils.py",
    "qualname": "requests.utils.prepend_scheme_if_needed",
    "function_def": [
      "def prepend_scheme_if_needed(url, new_scheme):",
      "    \"\"\"Given a URL that may or may not have a scheme, prepend the given scheme.",
      "    Does not replace a present scheme with the one provided as an argument.",
      "",
      "    :rtype: str",
      "    \"\"\"",
      "    parsed = parse_url(url)",
      "    scheme, auth, host, port, path, query, fragment = parsed",
      "",
      "    # A defect in urlparse determines that there isn't a netloc present in some",
      "    # urls. We previously assumed parsing was overly cautious, and swapped the",
      "    # netloc and path. Due to a lack of tests on the original defect, this is",
      "    # maintained with parse_url for backwards compatibility.",
      "    netloc = parsed.netloc",
      "    if not netloc:",
      "        netloc, path = path, netloc",
      "",
      "    if auth:",
      "        # parse_url doesn't provide the netloc with auth",
      "        # so we'll add it ourselves.",
      "        netloc = \"@\".join([auth, netloc])",
      "    if scheme is None:",
      "        scheme = new_scheme",
      "    if path is None:",
      "        path = \"\"",
      "",
      "    return urlunparse((scheme, netloc, path, \"\", query, fragment))"
    ],
    "test_cases": [
      {
        "id": 1,
        "test_name": "test_prepend_scheme_if_needed",
        "test_file": "requests/tests/test_utils.py",
        "test_nodeid": "requests/tests/test_utils.py::test_prepend_scheme_if_needed",
        "test_code": [
          "@pytest.mark.parametrize(",
          "    \"value, expected\",",
          "    (",
          "        (\"example.com/path\", \"http://example.com/path\"),",
          "        (\"//example.com/path\", \"http://example.com/path\"),",
          "        (\"example.com:80\", \"http://example.com:80\"),",
          "        (\"http://user:pass@example.com/path?query\", \"http://user:pass@example.com/path?query\"),",
          "        (\"http://user@example.com/path?query\", \"http://user@example.com/path?query\"),",
          "    ),",
          ")",
          "def test_prepend_scheme_if_needed(value, expected):",
          "    assert prepend_scheme_if_needed(value, \"http\") == expected"
        ]
      }
    ],
    "fixtures": [],
    "description": "Ensure a scheme (e.g., 'http') is prepended when missing; preserve existing scheme, auth, host, port, path and query. Handles protocol-relative URLs and cases where parse_url may swap netloc/path.",
    "security_focus": [
      "url_canonicalization",
      "credential_handling (preserve/remove auth as appropriate)",
      "sensitive_output_disclosure"
    ],
    "setup_notes": {
      "note": "Unit tests in test_utils.py are self-contained; include parametrized examples so the LLM sees protocol-relative, existing-scheme, and auth-containing cases. No network fixtures required."
    }
  },
  {
  "name": "_basic_auth_str",
  "module": "requests.auth",
  "file": "requests/src/requests/auth.py",
  "qualname": "requests.auth._basic_auth_str",
  "function_def": [
    "def _basic_auth_str(username, password):",
    "    \"\"\"Returns a Basic Auth string.\"\"\"",
    "",
    "    # \"I want us to put a big-ol' comment on top of it that",
    "    # says that this behaviour is dumb but we need to preserve",
    "    # it because people are relying on it.\"",
    "    #    - Lukasa",
    "    #",
    "    # These are here solely to maintain backwards compatibility",
    "    # for things like ints. This will be removed in 3.0.0.",
    "    if not isinstance(username, basestring):",
    "        warnings.warn(",
    "            \"Non-string usernames will no longer be supported in Requests \"",
    "            \"3.0.0. Please convert the object you've passed in ({!r}) to \"",
    "            \"a string or bytes object in the near future to avoid \"",
    "            \"problems.\".format(username),",
    "            category=DeprecationWarning,",
    "        )",
    "        username = str(username)",
    "",
    "    if not isinstance(password, basestring):",
    "        warnings.warn(",
    "            \"Non-string passwords will no longer be supported in Requests \"",
    "            \"3.0.0. Please convert the object you've passed in ({!r}) to \"",
    "            \"a string or bytes object in the near future to avoid \"",
    "            \"problems.\".format(type(password)),",
    "            category=DeprecationWarning,",
    "        )",
    "        password = str(password)",
    "    # -- End Removal --",
    "",
    "    if isinstance(username, str):",
    "        username = username.encode(\"latin1\")",
    "",
    "    if isinstance(password, str):",
    "        password = password.encode(\"latin1\")",
    "",
    "    authstr = \"Basic \" + to_native_string(",
    "        b64encode(b\":\".join((username, password))).strip()",
    "    )",
    "",
    "    return authstr"
  ],
  "test_cases": [
    {
      "id": 1,
      "test_name": "test_set_basicauth",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_set_basicauth",
      "test_code": [
        "@pytest.mark.parametrize(",
        "    \"username, password\",",
        "    (",
        "        (\"user\", \"pass\"),",
        "        (\"имя\".encode(), \"пароль\".encode()),",
        "        (42, 42),",
        "        (None, None),",
        "    ),",
        ")",
        "def test_set_basicauth(self, httpbin, username, password):",
        "    auth = (username, password)",
        "    url = httpbin(\"get\")",
        "",
        "    r = requests.Request(\"GET\", url, auth=auth)",
        "    p = r.prepare()",
        "",
        "    assert p.headers[\"Authorization\"] == _basic_auth_str(username, password)"
      ]
    },
    {
      "id": 2,
      "test_name": "test_basic_auth_str_is_always_native",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_basic_auth_str_is_always_native",
      "test_code": [
        "@pytest.mark.parametrize(",
        "    \"username, password, auth_str\",",
        "    (",
        "        (\"test\", \"test\", \"Basic dGVzdDp0ZXN0\"),",
        "        (",
        "            \"имя\".encode(),",
        "            \"пароль\".encode(),",
        "            \"Basic 0LjQvNGPOtC/0LDRgNC+0LvRjA==\",",
        "        ),",
        "    ),",
        ")",
        "def test_basic_auth_str_is_always_native(self, username, password, auth_str):",
        "    s = _basic_auth_str(username, password)",
        "    assert isinstance(s, builtin_str)",
        "    assert s == auth_str"
      ]
    }
  ],
  "fixtures": [
    "httpbin (used by test_set_basicauth for simple HTTP endpoints)",
    "builtin_str (type alias used in tests for native/string assertions)"
  ],
  "description": "Constructs a Basic Authorization header value from username and password. Handles bytes, str, and non-string inputs (with deprecation warnings), encodes str to latin-1 bytes, base64-encodes the username:password pair and returns a native string prefixed with 'Basic '.",
  "security_focus": [
    "credential_handling",
    "sensitive_output_disclosure",
    "output_sanitization",
    "header_injection (CRLF)"
  ],
  "setup_notes": {
    "note": "The example tests reference fixtures (httpbin, builtin_str) and may rely on module-level imports/fixtures in the test suite. When sending this entry to an LLM, include a brief note asking the model to either mock those fixtures or produce self-contained tests that do not require the full test harness.",
    "recommendation": "Prefer providing minimal stubs for httpbin or instruct the LLM to use tmp_path/monkeypatch to avoid network and heavy fixtures."
  }
  },
  {
  "name": "HTTPDigestAuth",
  "module": "requests.auth",
  "file": "requests/src/requests/auth.py",
  "qualname": "requests.auth.HTTPDigestAuth",
  "function_def": [
    "class HTTPDigestAuth(AuthBase):",
    "    \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"",
    "",
    "    def __init__(self, username, password):",
    "        self.username = username",
    "        self.password = password",
    "        # Keep state in per-thread local storage",
    "        self._thread_local = threading.local()",
    "",
    "    def init_per_thread_state(self):",
    "        # Ensure state is initialized just once per-thread",
    "        if not hasattr(self._thread_local, \"init\"):",
    "            self._thread_local.init = True",
    "            self._thread_local.last_nonce = \"\"",
    "            self._thread_local.nonce_count = 0",
    "            self._thread_local.chal = {}",
    "            self._thread_local.pos = None",
    "            self._thread_local.num_401_calls = None",
    "",
    "    def build_digest_header(self, method, url):",
    "        \"\"\"",
    "        :rtype: str",
    "        \"\"\"",
    "",
    "        realm = self._thread_local.chal[\"realm\"]",
    "        nonce = self._thread_local.chal[\"nonce\"]",
    "        qop = self._thread_local.chal.get(\"qop\")",
    "        algorithm = self._thread_local.chal.get(\"algorithm\")",
    "        opaque = self._thread_local.chal.get(\"opaque\")",
    "        hash_utf8 = None",
    "",
    "        if algorithm is None:",
    "            _algorithm = \"MD5\"",
    "        else:",
    "            _algorithm = algorithm.upper()",
    "        if _algorithm == \"MD5\" or _algorithm == \"MD5-SESS\":",
    "            def md5_utf8(x):",
    "                if isinstance(x, str):",
    "                    x = x.encode(\"utf-8\")",
    "                return hashlib.md5(x).hexdigest()",
    "            hash_utf8 = md5_utf8",
    "        elif _algorithm == \"SHA\":",
    "            def sha_utf8(x):",
    "                if isinstance(x, str):",
    "                    x = x.encode(\"utf-8\")",
    "                return hashlib.sha1(x).hexdigest()",
    "            hash_utf8 = sha_utf8",
    "        elif _algorithm == \"SHA-256\":",
    "            def sha256_utf8(x):",
    "                if isinstance(x, str):",
    "                    x = x.encode(\"utf-8\")",
    "                return hashlib.sha256(x).hexdigest()",
    "            hash_utf8 = sha256_utf8",
    "        elif _algorithm == \"SHA-512\":",
    "            def sha512_utf8(x):",
    "                if isinstance(x, str):",
    "                    x = x.encode(\"utf-8\")",
    "                return hashlib.sha512(x).hexdigest()",
    "            hash_utf8 = sha512_utf8",
    "",
    "        KD = lambda s, d: hash_utf8(f\"{s}:{d}\")",
    "",
    "        if hash_utf8 is None:",
    "            return None",
    "",
    "        entdig = None",
    "        p_parsed = urlparse(url)",
    "        path = p_parsed.path or \"/\"",
    "        if p_parsed.query:",
    "            path += f\"?{p_parsed.query}\"",
    "",
    "        A1 = f\"{self.username}:{realm}:{self.password}\"",
    "        A2 = f\"{method}:{path}\"",
    "",
    "        HA1 = hash_utf8(A1)",
    "        HA2 = hash_utf8(A2)",
    "",
    "        if nonce == self._thread_local.last_nonce:",
    "            self._thread_local.nonce_count += 1",
    "        else:",
    "            self._thread_local.nonce_count = 1",
    "        ncvalue = f\"{self._thread_local.nonce_count:08x}\"",
    "        s = str(self._thread_local.nonce_count).encode(\"utf-8\")",
    "        s += nonce.encode(\"utf-8\")",
    "        s += time.ctime().encode(\"utf-8\")",
    "        s += os.urandom(8)",
    "",
    "        cnonce = hashlib.sha1(s).hexdigest()[:16]",
    "        if _algorithm == \"MD5-SESS\":",
    "            HA1 = hash_utf8(f\"{HA1}:{nonce}:{cnonce}\")",
    "",
    "        if not qop:",
    "            respdig = KD(HA1, f\"{nonce}:{HA2}\")",
    "        elif qop == \"auth\" or \"auth\" in qop.split(\",\"):",
    "            noncebit = f\"{nonce}:{ncvalue}:{cnonce}:auth:{HA2}\"",
    "            respdig = KD(HA1, noncebit)",
    "        else:",
    "            return None",
    "",
    "        self._thread_local.last_nonce = nonce",
    "",
    "        base = (",
    "            f'username=\"{self.username}\", realm=\"{realm}\", nonce=\"{nonce}\", '",
    "            f'uri=\"{path}\", response=\"{respdig}\"'",
    "        )",
    "        if opaque:",
    "            base += f', opaque=\"{opaque}\"'",
    "        if algorithm:",
    "            base += f', algorithm=\"{algorithm}\"'",
    "        if entdig:",
    "            base += f', digest=\"{entdig}\"'",
    "        if qop:",
    "            base += f', qop=\"auth\", nc={ncvalue}, cnonce=\"{cnonce}\"'",
    "",
    "        return f\"Digest {base}\"",
    "",
    "    def handle_redirect(self, r, **kwargs):",
    "        \"\"\"Reset num_401_calls counter on redirects.\"\"\"",
    "        if r.is_redirect:",
    "            self._thread_local.num_401_calls = 1",
    "",
    "    def handle_401(self, r, **kwargs):",
    "        \"\"\"Take the given response and tries digest-auth, if needed.\"\"\"",
    "        if not 400 <= r.status_code < 500:",
    "            self._thread_local.num_401_calls = 1",
    "            return r",
    "",
    "        if self._thread_local.pos is not None:",
    "            r.request.body.seek(self._thread_local.pos)",
    "        s_auth = r.headers.get(\"www-authenticate\", \"\")",
    "",
    "        if \"digest\" in s_auth.lower() and self._thread_local.num_401_calls < 2:",
    "            self._thread_local.num_401_calls += 1",
    "            pat = re.compile(r\"digest \", flags=re.IGNORECASE)",
    "            self._thread_local.chal = parse_dict_header(pat.sub(\"\", s_auth, count=1))",
    "",
    "            r.content",
    "            r.close()",
    "            prep = r.request.copy()",
    "            extract_cookies_to_jar(prep._cookies, r.request, r.raw)",
    "            prep.prepare_cookies(prep._cookies)",
    "",
    "            prep.headers[\"Authorization\"] = self.build_digest_header(prep.method, prep.url)",
    "            _r = r.connection.send(prep, **kwargs)",
    "            _r.history.append(r)",
    "            _r.request = prep",
    "",
    "            return _r",
    "",
    "        self._thread_local.num_401_calls = 1",
    "        return r",
    "",
    "    def __call__(self, r):",
    "        self.init_per_thread_state()",
    "        if self._thread_local.last_nonce:",
    "            r.headers[\"Authorization\"] = self.build_digest_header(r.method, r.url)",
    "        try:",
    "            self._thread_local.pos = r.body.tell()",
    "        except AttributeError:",
    "            self._thread_local.pos = None",
    "        r.register_hook(\"response\", self.handle_401)",
    "        r.register_hook(\"response\", self.handle_redirect)",
    "        self._thread_local.num_401_calls = 1",
    "",
    "        return r"
  ],
  "test_cases": [
    {
      "id": 1,
      "test_name": "test_DIGEST_HTTP_200_OK_GET",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_DIGEST_HTTP_200_OK_GET",
      "test_code": [
        "def test_DIGEST_HTTP_200_OK_GET(self, httpbin):",
        "    for authtype in self.digest_auth_algo:",
        "        auth = HTTPDigestAuth(\"user\", \"pass\")",
        "        url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype, \"never\")",
        "",
        "        r = requests.get(url, auth=auth)",
        "        assert r.status_code == 200",
        "",
        "        r = requests.get(url)",
        "        assert r.status_code == 401",
        "",
        "        s = requests.session()",
        "        s.auth = HTTPDigestAuth(\"user\", \"pass\")",
        "        r = s.get(url)",
        "        assert r.status_code == 200"
      ]
    },
    {
      "id": 2,
      "test_name": "test_DIGEST_AUTH_RETURNS_COOKIE",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_DIGEST_AUTH_RETURNS_COOKIE",
      "test_code": [
        "def test_DIGEST_AUTH_RETURNS_COOKIE(self, httpbin):",
        "    for authtype in self.digest_auth_algo:",
        "        url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)",
        "        auth = HTTPDigestAuth(\"user\", \"pass\")",
        "        r = requests.get(url)",
        "        assert r.cookies[\"fake\"] == \"fake_value\"",
        "",
        "        r = requests.get(url, auth=auth)",
        "        assert r.status_code == 200"
      ]
    },
    {
      "id": 3,
      "test_name": "test_DIGEST_AUTH_SETS_SESSION_COOKIES",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_DIGEST_AUTH_SETS_SESSION_COOKIES",
      "test_code": [
        "def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self, httpbin):",
        "    for authtype in self.digest_auth_algo:",
        "        url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)",
        "        auth = HTTPDigestAuth(\"user\", \"pass\")",
        "        s = requests.Session()",
        "        s.get(url, auth=auth)",
        "        assert s.cookies[\"fake\"] == \"fake_value\""
      ]
    },
    {
      "id": 4,
      "test_name": "test_DIGEST_STREAM",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_DIGEST_STREAM",
      "test_code": [
        "def test_DIGEST_STREAM(self, httpbin):",
        "    for authtype in self.digest_auth_algo:",
        "        auth = HTTPDigestAuth(\"user\", \"pass\")",
        "        url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)",
        "",
        "        r = requests.get(url, auth=auth, stream=True)",
        "        assert r.raw.read() != b\"\"",
        "",
        "        r = requests.get(url, auth=auth, stream=False)",
        "        assert r.raw.read() == b\"\""
      ]
    },
    {
      "id": 5,
      "test_name": "test_DIGESTAUTH_WRONG_HTTP_401_GET",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_DIGESTAUTH_WRONG_HTTP_401_GET",
      "test_code": [
        "def test_DIGESTAUTH_WRONG_HTTP_401_GET(self, httpbin):",
        "    for authtype in self.digest_auth_algo:",
        "        auth = HTTPDigestAuth(\"user\", \"wrongpass\")",
        "        url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)",
        "",
        "        r = requests.get(url, auth=auth)",
        "        assert r.status_code == 401",
        "",
        "        r = requests.get(url)",
        "        assert r.status_code == 401",
        "",
        "        s = requests.session()",
        "        s.auth = auth",
        "        r = s.get(url)",
        "        assert r.status_code == 401"
      ]
    },
    {
      "id": 6,
      "test_name": "test_DIGESTAUTH_QUOTES_QOP_VALUE",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_DIGESTAUTH_QUOTES_QOP_VALUE",
      "test_code": [
        "def test_DIGESTAUTH_QUOTES_QOP_VALUE(self, httpbin):",
        "    for authtype in self.digest_auth_algo:",
        "        auth = HTTPDigestAuth(\"user\", \"pass\")",
        "        url = httpbin(\"digest-auth\", \"auth\", \"user\", \"pass\", authtype)",
        "",
        "        r = requests.get(url, auth=auth)",
        "        assert '\"auth\"' in r.request.headers[\"Authorization\"]"
      ]
    }
  ],
  "fixtures": [
    "httpbin (used by existing integration tests to emit WWW-Authenticate challenges)",
    "threading (class uses thread-local state)",
    "pytest (parametrize / fixtures)"
  ],
  "description": "Implements RFC-style HTTP Digest Authentication: builds digest Authorization headers (build_digest_header), handles 401 flows (handle_401), manages per-thread state (init_per_thread_state), and registers response hooks. Useful security-relevant behaviors: header construction, nonce/cnonce handling, body rewind, and redirect/auth stripping.",
  "security_focus": [
    "credential_handling",
    "authorization_header_leakage",
    "redirect_safety",
    "body_rewind_and_leakage",
    "parsing_of_www_authenticate"
  ],
  "setup_notes": {
    "note": "Integration tests rely on the httpbin fixture. For single-function unit examples, populate an HTTPDigestAuth instance's _thread_local.chal with a minimal challenge (realm, nonce, qop, algorithm) and call build_digest_header(method, url). When sending this entry to an LLM, instruct it to produce self-contained unit tests that either mock the httpbin flow or directly call build_digest_header after setting thread-local state.",
    "recommendation": "Prefer supplying one small unit test targeting build_digest_header (pre-populate chal and nonce state) and one integration-style example that uses httpbin but instruct the LLM to mock network."
  }
  },
  {
  "name": "unquote_header_value",
  "module": "requests.utils",
  "file": "requests/src/requests/utils.py",
  "qualname": "requests.utils.unquote_header_value",
  "function_def": [
    "def unquote_header_value(value, is_filename=False):",
    "    r\"\"\"Unquotes a header value.  (Reversal of :func:`quote_header_value`).",
    "    This does not use the real unquoting but what browsers are actually",
    "    using for quoting.",
    "",
    "    :param value: the header value to unquote.",
    "    :rtype: str",
    "    \"\"\"",
    "    if value and value[0] == value[-1] == '\"':",
    "        # this is not the real unquoting, but fixing this so that the",
    "        # RFC is met will result in bugs with internet explorer and",
    "        # probably some other browsers as well.  IE for example is",
    "        # uploading files with \"C:\\\\foo\\\\bar.txt\" as filename",
    "        value = value[1:-1]",
    "",
    "        # if this is a filename and the starting characters look like",
    "        # a UNC path, then just return the value without quotes.  Using the",
    "        # replace sequence below on a UNC path has the effect of turning",
    "        # the leading double slash into a single slash and then",
    "        # _fix_ie_filename() doesn't work correctly.  See #458.",
    "        if not is_filename or value[:2] != \"\\\\\\\\\":",
    "            return value.replace('\\\\\\\\', '\\\\').replace('\\\"', '\"')",
    "    return value"
  ],
  "test_cases": [
    {
      "id": 1,
      "test_name": "test_valid",
      "test_file": "requests/tests/test_utils.py",
      "test_nodeid": "requests/tests/test_utils.py::TestUnquoteHeaderValue::test_valid",
      "test_code": [
        "@pytest.mark.parametrize(",
        "    \"value, expected\",",
        "    (",
        "        (None, None),",
        "        (\"Test\", \"Test\"),",
        "        ('\"Test\"', \"Test\"),",
        "        ('\"Test\\\\\\\\\"', \"Test\\\\\"),",
        "        ('\"\\\\\\\\Comp\\\\Res\"', \"\\\\Comp\\\\Res\"),",
        "    ),",
        ")",
        "def test_valid(value, expected):",
        "    assert unquote_header_value(value) == expected"
      ]
    },
    {
      "id": 2,
      "test_name": "test_is_filename",
      "test_file": "requests/tests/test_utils.py",
      "test_nodeid": "requests/tests/test_utils.py::TestUnquoteHeaderValue::test_is_filename",
      "test_code": [
        "def test_is_filename():",
        "    assert unquote_header_value('\"\\\\\\\\Comp\\\\Res\"', True) == \"\\\\\\\\Comp\\\\Res\""
      ]
    }
  ],
  "fixtures": [],
  "description": "Remove quotes from header values and unescape backslash sequences in a browser-compatible way. If is_filename is True and the value looks like a UNC path (starts with \\\\\"\\\\\\\\), return the raw value without applying the backslash replacements.",
  "security_focus": [
    "output_sanitization",
    "string_unquoting_edge_cases",
    "avoid_injection_via_headers"
  ],
  "setup_notes": {
    "note": "This is a pure unit-level test (no network). Include the parametrized examples so an LLM sees cases with None, plain strings, quoted strings, and escaped backslashes/UNC paths.",
    "recommendation": "When generating runnable tests from this example, ensure proper escaping is preserved in test source (Python string literals)."
  }
  },
  {
  "name": "_parse_content_type_header",
  "module": "requests.utils",
  "file": "requests/src/requests/utils.py",
  "qualname": "requests.utils._parse_content_type_header",
  "function_def": [
    "def _parse_content_type_header(header):",
    "    \"\"\"Returns content type and parameters from given header",
    "",
    "    :param header: string",
    "    :return: tuple containing content type and dictionary of",
    "         parameters",
    "    \"\"\"",
    "    tokens = header.split(\";\")",
    "    content_type, params = tokens[0].strip(), tokens[1:]",
    "    params_dict = {}",
    "    items_to_strip = \"\\\"' \"",
    "",
    "    for param in params:",
    "        param = param.strip()",
    "        if param:",
    "            key, value = param, True",
    "            index_of_equals = param.find(\"=\")",
    "            if index_of_equals != -1:",
    "                key = param[:index_of_equals].strip(items_to_strip)",
    "                value = param[index_of_equals + 1 :].strip(items_to_strip)",
    "            params_dict[key.lower()] = value",
    "    return content_type, params_dict"
  ],
  "test_cases": [
    {
      "id": 1,
      "test_name": "test__parse_content_type_header",
      "test_file": "requests/tests/test_utils.py",
      "test_nodeid": "requests/tests/test_utils.py::test__parse_content_type_header",
      "test_code": [
        "@pytest.mark.parametrize(",
        "    \"value, expected\",",
        "    (",
        "        (\"application/xml\", (\"application/xml\", {})),",
        "        (",
        "            \"application/json ; charset=utf-8\",",
        "            (\"application/json\", {\"charset\": \"utf-8\"}),",
        "        ),",
        "        (",
        "            \"application/json ; Charset=utf-8\",",
        "            (\"application/json\", {\"charset\": \"utf-8\"}),",
        "        ),",
        "        (\"text/plain\", (\"text/plain\", {})),",
        "        (",
        "            \"multipart/form-data; boundary = something ; boundary2='something_else' ; no_equals \",",
        "            (",
        "                \"multipart/form-data\",",
        "                {",
        "                    \"boundary\": \"something\",",
        "                    \"boundary2\": \"something_else\",",
        "                    \"no_equals\": True,",
        "                },",
        "            ),",
        "        ),",
        "        (",
        "            'multipart/form-data; boundary = something ; boundary2=\"something_else\" ; no_equals ',",
        "            (",
        "                \"multipart/form-data\",",
        "                {",
        "                    \"boundary\": \"something\",",
        "                    \"boundary2\": \"something_else\",",
        "                    \"no_equals\": True,",
        "                },",
        "            ),",
        "        ),",
        "        (",
        "            \"multipart/form-data; boundary = something ; 'boundary2=something_else' ; no_equals \",",
        "            (",
        "                \"multipart/form-data\",",
        "                {",
        "                    \"boundary\": \"something\",",
        "                    \"boundary2\": \"something_else\",",
        "                    \"no_equals\": True,",
        "                },",
        "            ),",
        "        ),",
        "        (",
        "            'multipart/form-data; boundary = something ; \"boundary2=something_else\" ; no_equals ',",
        "            (",
        "                \"multipart/form-data\",",
        "                {",
        "                    \"boundary\": \"something\",",
        "                    \"boundary2\": \"something_else\",",
        "                    \"no_equals\": True,",
        "                },",
        "            ),",
        "        ),",
        "        (\"application/json ; ; \", (\"application/json\", {})),",
        "    ),",
        ")",
        "def test__parse_content_type_header(value, expected):",
        "    assert _parse_content_type_header(value) == expected"
      ]
    }
  ],
  "fixtures": [],
  "description": "Parse a Content-Type header into (media_type, params_dict). Handles extra whitespace, quoted params, and missing values.",
  "security_focus": [
    "header_parsing",
    "parameter_injection",
    "correct_handling_of_quotes"
  ],
  "setup_notes": {
    "note": "Pure unit tests; include parametrized examples to show varied quoting and spacing cases."
  }
  },
  {
  "name": "select_proxy",
  "module": "requests.utils",
  "file": "requests/src/requests/utils.py",
  "qualname": "requests.utils.select_proxy",
  "function_def": [
    "def select_proxy(url, proxies):",
    "    \"\"\"Select a proxy for the url, if applicable.",
    "",
    "    :param url: The url being for the request",
    "    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs",
    "    \"\"\"",
    "    proxies = proxies or {}",
    "    urlparts = urlparse(url)",
    "    if urlparts.hostname is None:",
    "        return proxies.get(urlparts.scheme, proxies.get(\"all\"))",
    "",
    "    proxy_keys = [",
    "        urlparts.scheme + \"://\" + urlparts.hostname,",
    "        urlparts.scheme,",
    "        \"all://\" + urlparts.hostname,",
    "        \"all\",",
    "    ]",
    "    proxy = None",
    "    for proxy_key in proxy_keys:",
    "        if proxy_key in proxies:",
    "            proxy = proxies[proxy_key]",
    "            break",
    "",
    "    return proxy"
  ],
  "test_cases": [
    {
      "id": 1,
      "test_name": "test_select_proxies",
      "test_file": "requests/tests/test_utils.py",
      "test_nodeid": "requests/tests/test_utils.py::test_select_proxies",
      "test_code": [
        "http_proxies = {",
        "    \"http\": \"http://http.proxy\",",
        "    \"http://some.host\": \"http://some.host.proxy\",",
        "}",
        "all_proxies = {",
        "    \"all\": \"socks5://http.proxy\",",
        "    \"all://some.host\": \"socks5://some.host.proxy\",",
        "}",
        "mixed_proxies = {",
        "    \"http\": \"http://http.proxy\",",
        "    \"http://some.host\": \"http://some.host.proxy\",",
        "    \"all\": \"socks5://http.proxy\",",
        "}",
        "",
        "@pytest.mark.parametrize(",
        "    \"url, expected, proxies\",",
        "    (",
        "        (\"hTTp://u:p@Some.Host/path\", \"http://some.host.proxy\", http_proxies),",
        "        (\"hTTp://u:p@Other.Host/path\", \"http://http.proxy\", http_proxies),",
        "        (\"hTTp:///path\", \"http://http.proxy\", http_proxies),",
        "        (\"hTTps://Other.Host\", None, http_proxies),",
        "        (\"file:///etc/motd\", None, http_proxies),",
        "        (\"hTTp://u:p@Some.Host/path\", \"socks5://some.host.proxy\", all_proxies),",
        "        (\"hTTp://u:p@Other.Host/path\", \"socks5://http.proxy\", all_proxies),",
        "        (\"hTTp:///path\", \"socks5://http.proxy\", all_proxies),",
        "        (\"hTTps://Other.Host\", \"socks5://http.proxy\", all_proxies),",
        "        (\"http://u:p@other.host/path\", \"http://http.proxy\", mixed_proxies),",
        "        (\"http://u:p@some.host/path\", \"http://some.host.proxy\", mixed_proxies),",
        "        (\"https://u:p@other.host/path\", \"socks5://http.proxy\", mixed_proxies),",
        "        (\"https://u:p@some.host/path\", \"socks5://http.proxy\", mixed_proxies),",
        "        (\"https://\", \"socks5://http.proxy\", mixed_proxies),",
        "        # XXX: unsure whether this is reasonable behavior",
        "        (\"file:///etc/motd\", \"socks5://http.proxy\", all_proxies),",
        "    ),",
        ")",
        "def test_select_proxies(url, expected, proxies):",
        "    assert select_proxy(url, proxies) == expected"
      ]
    }
  ],
  "fixtures": [],
  "description": "Return the most specific matching proxy from the provided proxies mapping for a given URL. Preference order: scheme://hostname, scheme, all://hostname, all. Returns None if no match and hostname is present; uses scheme/all fallback when hostname is missing.",
  "security_focus": [
    "proxy_selection_correctness",
    "avoid_proxy_auth_leakage"
  ],
  "setup_notes": {
    "note": "Unit test is self-contained; ensure test imports the local utils.select_proxy implementation (PYTHONPATH) so it doesn't pick an installed package."
  }
  },
  {
  "name": "should_strip_auth",
  "module": "requests.sessions",
  "file": "requests/src/requests/sessions.py",
  "qualname": "requests.sessions.SessionRedirectMixin.should_strip_auth",
  "function_def": [
    "def should_strip_auth(self, old_url, new_url):",
    "    \"\"\"Decide whether Authorization header should be removed when redirecting\"\"\"",
    "    old_parsed = urlparse(old_url)",
    "    new_parsed = urlparse(new_url)",
    "    if old_parsed.hostname != new_parsed.hostname:",
    "        return True",
    "    # Special case: allow http -> https redirect when using the standard",
    "    # ports. This isn't specified by RFC 7235, but is kept to avoid",
    "    # breaking backwards compatibility with older versions of requests",
    "    # that allowed any redirects on the same host.",
    "    if (",
    "        old_parsed.scheme == \"http\"",
    "        and old_parsed.port in (80, None)",
    "        and new_parsed.scheme == \"https\"",
    "        and new_parsed.port in (443, None)",
    "    ):",
    "        return False",
    "",
    "    # Handle default port usage corresponding to scheme.",
    "    changed_port = old_parsed.port != new_parsed.port",
    "    changed_scheme = old_parsed.scheme != new_parsed.scheme",
    "    default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)",
    "    if (",
    "        not changed_scheme",
    "        and old_parsed.port in default_port",
    "        and new_parsed.port in default_port",
    "    ):",
    "        return False",
    "",
    "    # Standard case: root URI must match",
    "    return changed_port or changed_scheme"
  ],
  "test_cases": [
    {
      "id": 1,
      "test_name": "test_should_strip_auth_host_change",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_should_strip_auth_host_change",
      "test_code": [
        "def test_should_strip_auth_host_change(self):",
        "    s = requests.Session()",
        "    assert s.should_strip_auth(",
        "        \"http://example.com/foo\", \"http://another.example.com/\"",
        "    )"
      ]
    },
    {
      "id": 2,
      "test_name": "test_should_strip_auth_http_downgrade",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_should_strip_auth_http_downgrade",
      "test_code": [
        "def test_should_strip_auth_http_downgrade(self):",
        "    s = requests.Session()",
        "    assert s.should_strip_auth(\"https://example.com/foo\", \"http://example.com/bar\")"
      ]
    },
    {
      "id": 3,
      "test_name": "test_should_strip_auth_https_upgrade",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_should_strip_auth_https_upgrade",
      "test_code": [
        "def test_should_strip_auth_https_upgrade(self):",
        "    s = requests.Session()",
        "    assert not s.should_strip_auth(",
        "        \"http://example.com/foo\", \"https://example.com/bar\"",
        "    )",
        "    assert not s.should_strip_auth(",
        "        \"http://example.com:80/foo\", \"https://example.com/bar\"",
        "    )",
        "    assert not s.should_strip_auth(",
        "        \"http://example.com/foo\", \"https://example.com:443/bar\"",
        "    )",
        "    # Non-standard ports should trigger stripping",
        "    assert s.should_strip_auth(",
        "        \"http://example.com:8080/foo\", \"https://example.com/bar\"",
        "    )",
        "    assert s.should_strip_auth(",
        "        \"http://example.com/foo\", \"https://example.com:8443/bar\"",
        "    )"
      ]
    },
    {
      "id": 4,
      "test_name": "test_should_strip_auth_port_change",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_should_strip_auth_port_change",
      "test_code": [
        "def test_should_strip_auth_port_change(self):",
        "    s = requests.Session()",
        "    assert s.should_strip_auth(",
        "        \"http://example.com:1234/foo\", \"https://example.com:4321/bar\"",
        "    )"
      ]
    },
    {
      "id": 5,
      "test_name": "test_should_strip_auth_default_port",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_should_strip_auth_default_port",
      "test_code": [
        "@pytest.mark.parametrize(",
        "    \"old_uri, new_uri\",",
        "    (",
        "        (\"https://example.com:443/foo\", \"https://example.com/bar\"),",
        "        (\"http://example.com:80/foo\", \"http://example.com/bar\"),",
        "        (\"https://example.com/foo\", \"https://example.com:443/bar\"),",
        "        (\"http://example.com/foo\", \"http://example.com:80/bar\"),",
        "    ),",
        ")",
        "def test_should_strip_auth_default_port(self, old_uri, new_uri):",
        "    s = requests.Session()",
        "    assert not s.should_strip_auth(old_uri, new_uri)"
      ]
    }
  ],
  "fixtures": [
    "requests.Session() (used to call the mixin method in tests)",
    "pytest (for parametrize)"
  ],
  "description": "Decide whether Authorization header should be stripped when following redirects. Covers hostname changes, http->https/https->http port/scheme rules, and default-port equivalence handling.",
  "security_focus": [
    "authorization_header_leakage",
    "redirect_safety",
    "credential_exposure_on_host_change"
  ],
  "setup_notes": {
    "note": "Mostly E2E. Unit tests call the session.should_strip_auth from a Session instance. Ensure imports resolve to the local sessions module when running tests (PYTHONPATH). Parametrized test preserved as-is."
  }
  },
  {
  "name": "rebuild_auth",
  "module": "requests.sessions",
  "file": "requests/src/requests/sessions.py",
  "qualname": "requests.sessions.SessionRedirectMixin.rebuild_auth",
  "function_def": [
    "def rebuild_auth(self, prepared_request, response):",
    "    \"\"\"When being redirected we may want to strip authentication from the",
    "    request to avoid leaking credentials. This method intelligently removes",
    "    and reapplies authentication where possible to avoid credential loss.",
    "    \"\"\"",
    "    headers = prepared_request.headers",
    "    url = prepared_request.url",
    "",
    "    if \"Authorization\" in headers and self.should_strip_auth(",
    "        response.request.url, url",
    "    ):",
    "        # If we get redirected to a new host, we should strip out any",
    "        # authentication headers.",
    "        del headers[\"Authorization\"]",
    "",
    "    # .netrc might have more auth for us on our new host.",
    "    new_auth = get_netrc_auth(url) if self.trust_env else None",
    "    if new_auth is not None:",
    "        prepared_request.prepare_auth(new_auth)"
  ],
  "test_cases": [
    {
      "id": 1,
      "test_name": "test_auth_is_stripped_on_http_downgrade",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_auth_is_stripped_on_http_downgrade",
      "test_code": [
        "def test_auth_is_stripped_on_http_downgrade(self, httpbin, httpbin_secure, httpbin_ca_bundle):",
        "    r = requests.get(",
        "        httpbin_secure(\"redirect-to\"),",
        "        params={\"url\": httpbin(\"get\")},",
        "        auth=(\"user\", \"pass\"),",
        "        verify=httpbin_ca_bundle,",
        "    )",
        "    assert r.history[0].request.headers[\"Authorization\"]",
        "    assert \"Authorization\" not in r.request.headers"
      ]
    },
    {
      "id": 2,
      "test_name": "test_auth_is_retained_for_redirect_on_host",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_auth_is_retained_for_redirect_on_host",
      "test_code": [
        "def test_auth_is_retained_for_redirect_on_host(self, httpbin):",
        "    r = requests.get(httpbin(\"redirect/1\"), auth=(\"user\", \"pass\"))",
        "    h1 = r.history[0].request.headers[\"Authorization\"]",
        "    h2 = r.request.headers[\"Authorization\"]",
        "",
        "    assert h1 == h2"
      ]
    }
  ],
  "fixtures": [
    "httpbin (local http test server)",
    "httpbin_secure (TLS-enabled httpbin for redirect->http downgrade test)",
    "httpbin_ca_bundle (CA bundle for secure httpbin)"
  ],
  "description": "Handle Authorization header during redirects: strip Authorization when should_strip_auth indicates leakage (e.g., http downgrade or host change) and re-apply .netrc credentials when available via get_netrc_auth (if trust_env).",
  "security_focus": [
    "authorization_header_leakage",
    "redirect_safety",
    "credential_exposure_on_redirects",
    "netrc_credential_handling"
  ],
  "setup_notes": {
    "note": "These are integration tests that expect the httpbin fixtures. For unit-style tests, mock SessionRedirectMixin.should_strip_auth, requests.sessions.get_netrc_auth and supply a PreparedRequest/Response pair to call rebuild_auth directly."
  }
  },
  {
  "name": "resolve_redirects",
  "module": "requests.sessions",
  "file": "requests/src/requests/sessions.py",
  "qualname": "requests.sessions.SessionRedirectMixin.resolve_redirects",
  "function_def": [
    "def resolve_redirects(self,",
    "        resp,",
    "        req,",
    "        stream=False,",
    "        timeout=None,",
    "        verify=True,",
    "        cert=None,",
    "        proxies=None,",
    "        yield_requests=False,",
    "        **adapter_kwargs,",
    "    ):",
    "    \"\"\"Receives a Response. Returns a generator of Responses or Requests.\"\"\"",
    "",
    "    hist = []  # keep track of history",
    "",
    "    url = self.get_redirect_target(resp)",
    "    previous_fragment = urlparse(req.url).fragment",
    "    while url:",
    "        prepared_request = req.copy()",
    "",
    "        # Update history and keep track of redirects.",
    "        # resp.history must ignore the original request in this loop",
    "        hist.append(resp)",
    "        resp.history = hist[1:]",
    "",
    "        try:",
    "            resp.content  # Consume socket so it can be released",
    "        except (ChunkedEncodingError, ContentDecodingError, RuntimeError):",
    "            resp.raw.read(decode_content=False)",
    "",
    "        if len(resp.history) >= self.max_redirects:",
    "            raise TooManyRedirects(",
    "                f\"Exceeded {self.max_redirects} redirects.\", response=resp",
    "            )",
    "",
    "        # Release the connection back into the pool.",
    "        resp.close()",
    "",
    "        # Handle redirection without scheme (see: RFC 1808 Section 4)",
    "        if url.startswith(\"//\"):",
    "            parsed_rurl = urlparse(resp.url)",
    "            url = \":\".join([to_native_string(parsed_rurl.scheme), url])",
    "",
    "        # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)",
    "        parsed = urlparse(url)",
    "        if parsed.fragment == \"\" and previous_fragment:",
    "            parsed = parsed._replace(fragment=previous_fragment)",
    "        elif parsed.fragment:",
    "            previous_fragment = parsed.fragment",
    "        url = parsed.geturl()",
    "",
    "        # Facilitate relative 'location' headers, as allowed by RFC 7231.",
    "        # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')",
    "        # Compliant with RFC3986, we percent encode the url.",
    "        if not parsed.netloc:",
    "            url = urljoin(resp.url, requote_uri(url))",
    "        else:",
    "            url = requote_uri(url)",
    "",
    "        prepared_request.url = to_native_string(url)",
    "",
    "        self.rebuild_method(prepared_request, resp)",
    "",
    "        # https://github.com/psf/requests/issues/1084",
    "        if resp.status_code not in (",
    "            codes.temporary_redirect,",
    "            codes.permanent_redirect,",
    "        ):",
    "            # https://github.com/psf/requests/issues/3490",
    "            purged_headers = (\"Content-Length\", \"Content-Type\", \"Transfer-Encoding\")",
    "            for header in purged_headers:",
    "                prepared_request.headers.pop(header, None)",
    "            prepared_request.body = None",
    "",
    "        headers = prepared_request.headers",
    "        headers.pop(\"Cookie\", None)",
    "",
    "        # Extract any cookies sent on the response to the cookiejar",
    "        # in the new request. Because we've mutated our copied prepared",
    "        # request, use the old one that we haven't yet touched.",
    "        extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)",
    "        merge_cookies(prepared_request._cookies, self.cookies)",
    "        prepared_request.prepare_cookies(prepared_request._cookies)",
    "",
    "        # Rebuild auth and proxy information.",
    "        proxies = self.rebuild_proxies(prepared_request, proxies)",
    "        self.rebuild_auth(prepared_request, resp)",
    "",
    "        # A failed tell() sets `_body_position` to `object()`. This non-None",
    "        # value ensures `rewindable` will be True, allowing us to raise an",
    "        # UnrewindableBodyError, instead of hanging the connection.",
    "        rewindable = prepared_request._body_position is not None and (",
    "            \"Content-Length\" in headers or \"Transfer-Encoding\" in headers",
    "        )",
    "",
    "        # Attempt to rewind consumed file-like object.",
    "        if rewindable:",
    "            rewind_body(prepared_request)",
    "",
    "        # Override the original request.",
    "        req = prepared_request",
    "",
    "        if yield_requests:",
    "            yield req",
    "        else:",
    "            resp = self.send(",
    "                req,",
    "                stream=stream,",
    "                timeout=timeout,",
    "                verify=verify,",
    "                cert=cert,",
    "                proxies=proxies,",
    "                allow_redirects=False,",
    "                **adapter_kwargs,",
    "            )",
    "",
    "            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)",
    "",
    "            # extract redirect url, if any, for the next loop",
    "            url = self.get_redirect_target(resp)",
    "            yield resp"
  ],
  "test_cases": [
    {
      "id": 1,
      "test_name": "test_HTTP_302_ALLOW_REDIRECT_GET",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_HTTP_302_ALLOW_REDIRECT_GET",
      "test_code": [
        "def test_HTTP_302_ALLOW_REDIRECT_GET(self, httpbin):",
        "    r = requests.get(httpbin('redirect', '1'))",
        "    assert r.status_code == 200",
        "    assert r.history[0].status_code == 302",
        "    assert r.history[0].is_redirect"
      ]
    },
    {
      "id": 2,
      "test_name": "test_HTTP_307_ALLOW_REDIRECT_POST",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_HTTP_307_ALLOW_REDIRECT_POST",
      "test_code": [
        "def test_HTTP_307_ALLOW_REDIRECT_POST(self, httpbin):",
        "    r = requests.post(",
        "        httpbin('redirect-to'),",
        "        data='test',",
        "        params={'url': 'post', 'status_code': 307},",
        "    )",
        "    assert r.status_code == 200",
        "    assert r.history[0].status_code == 307",
        "    assert r.history[0].is_redirect",
        "    assert r.json()['data'] == 'test'"
      ]
    },
    {
      "id": 3,
      "test_name": "test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE",
      "test_code": [
        "def test_HTTP_307_ALLOW_REDIRECT_POST_WITH_SEEKABLE(self, httpbin):",
        "    byte_str = b'test'",
        "    r = requests.post(",
        "        httpbin('redirect-to'),",
        "        data=io.BytesIO(byte_str),",
        "        params={'url': 'post', 'status_code': 307},",
        "    )",
        "    assert r.status_code == 200",
        "    assert r.history[0].status_code == 307",
        "    assert r.history[0].is_redirect",
        "    assert r.json()['data'] == byte_str.decode('utf-8')"
      ]
    },
    {
      "id": 4,
      "test_name": "test_HTTP_302_TOO_MANY_REDIRECTS",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_HTTP_302_TOO_MANY_REDIRECTS",
      "test_code": [
        "def test_HTTP_302_TOO_MANY_REDIRECTS(self, httpbin):",
        "    try:",
        "        requests.get(httpbin('relative-redirect', '50'))",
        "    except TooManyRedirects as e:",
        "        url = httpbin('relative-redirect', '20')",
        "        assert e.request.url == url",
        "        assert e.response.url == url",
        "        assert len(e.response.history) == 30",
        "    else:",
        "        pytest.fail('Expected redirect to raise TooManyRedirects but it did not')"
      ]
    },
    {
      "id": 5,
      "test_name": "test_fragment_maintained_on_redirect",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_fragment_maintained_on_redirect",
      "test_code": [
        "def test_fragment_maintained_on_redirect(self, httpbin):",
        "    fragment = '#view=edit&token=hunter2'",
        "    r = requests.get(httpbin('redirect-to?url=get') + fragment)",
        "    assert len(r.history) > 0",
        "    assert r.history[0].request.url == httpbin('redirect-to?url=get') + fragment",
        "    assert r.url == httpbin('get') + fragment"
      ]
    },
    {
      "id": 6,
      "test_name": "test_HTTP_200_OK_GET_WITH_PARAMS",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_HTTP_200_OK_GET_WITH_PARAMS",
      "test_code": [
        "def test_HTTP_200_OK_GET_WITH_PARAMS(self, httpbin):",
        "    heads = {'User-agent': 'Mozilla/5.0'}",
        "    r = requests.get(httpbin('user-agent'), headers=heads)",
        "    assert heads['User-agent'] in r.text",
        "    assert r.status_code == 200"
      ]
    },
    {
      "id": 7,
      "test_name": "test_manual_redirect_with_partial_body_read",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_manual_redirect_with_partial_body_read",
      "test_code": [
        "def test_manual_redirect_with_partial_body_read(self, httpbin):",
        "    s = requests.Session()",
        "    r1 = s.get(httpbin('redirect/2'), allow_redirects=False, stream=True)",
        "    assert r1.is_redirect",
        "    rg = s.resolve_redirects(r1, r1.request, stream=True)",
        "    # read only the first eight bytes of the response body, then follow the redirect",
        "    r1.iter_content(8)",
        "    r2 = next(rg)",
        "    assert r2.is_redirect",
        "    # read all of the response via iter_content, then follow the redirect",
        "    for _ in r2.iter_content():",
        "        pass",
        "    r3 = next(rg)",
        "    assert not r3.is_redirect"
      ]
    },
    {
      "id": 8,
      "test_name": "test_redirect_with_wrong_gzipped_header",
      "test_file": "requests/tests/test_requests.py",
      "test_nodeid": "requests/tests/test_requests.py::TestRequests::test_redirect_with_wrong_gzipped_header",
      "test_code": [
        "def test_redirect_with_wrong_gzipped_header(self, httpbin):",
        "    s = requests.Session()",
        "    url = httpbin('redirect/1')",
        "    # patch adapter to return a gzipped header once to exercise branch",
        "    self._patch_adapter_gzipped_redirect(s, url)",
        "    s.get(url)"
      ]
    }
  ],
  "fixtures": [
    "httpbin (local http test server)",
    "io (used by seekable body test)",
    "requests.Session (session used to exercise resolve_redirects)",
    "pytest (for assertions/parametrize)"
  ],
  "description": "Generator in SessionRedirectMixin that follows redirect responses. Handles relative/absolute locations, fragment preservation, cookie transfer, header purging, rewinding bodies, rebuilding proxies/auth, and max_redirects enforcement.",
  "security_focus": [
    "authorization_header_leakage_on_redirect",
    "cookie_handling_during_redirect",
    "body_rewind_and_unrewindable_checks",
    "redirect_loop_detection"
  ],
  "setup_notes": {
    "note": "These tests are end-to-end and rely on the httpbin fixture (and in one case a patched adapter). For unit tests, mock network/adapter behavior and construct Response/PreparedRequest objects to iterate resolve_redirects directly."
  }
  }  
]
