You are given a target function from a Python library about HTTP requests.
Your task is to use pytest and generate complete, executable and unique test cases for this target function. 
The Python version is 3.11.
The pytest version is 8.4.2.

=================================================================================================================
Target function name:
{{FUNCTION_NAME}}



Target function definition:
{{FUNCTION_DEFINITION}}



Target function module name:
{{FUNCTION_MODULE}}



Imports used by the module that defines {{FUNCTION_NAME}}:
{{IMPORTS}}



Dependency or helper functions for the target function (for context only):
{{DEPENDENCIES}}

=================================================================================================================

For generating the tests, follow these rules:

HARD CONSTRAINTS (non-negotiable):
1. You MUST output one or more test files. Each test file is delimited by:
===TESTCASE_FILE_START===
<python code>
===TESTCASE_FILE_END===

2. Inside EACH test file:
2.1 There MUST be EXACTLY ONE function definition whose name starts with "test_".
- Exactly one "def test_" is allowed.
- ZERO other "def test_" functions are allowed.
- No nested test functions.
2.2 The file MUST test EXACTLY ONE scenario / behavior.
- Do NOT combine multiple cases in one test.
- No "Case 1/Case 2/..." sections.
- No multiple input variations in one test.
- No multiple independent asserts for different behaviors.
(Multiple asserts are allowed ONLY if they all validate the SAME single scenario, e.g., value equality + type.)

3. Self-containment rules: 
- The test file MUST be executable as-is by pytest.
- Do not rely on shared state between test cases.
- You MUST NOT paste or reimplement {{FUNCTION_NAME}} in the test file.
- Include all necessary imports correctly to avoid collection failures.
- Dependency/helper functions are provided for context only; do NOT write tests for them.
- All generated tests must directly only {{FUNCTION_NAME}}.
- Do NOT reimplement dependency functions, prefer mocking and define the mocks correctly by inspecting the provided dependencies. 
- Make sure you define mock attributes correctly and avoid causing "AttributeError: Mock object has no attribute". Ensure mocked objects implement all attributes actually accessed.
- Respect type contracts shown in the provided dependencies. If a function performs isinstance checks, use real library instances or factory helpers; do not replace core types with Mock.
- When a method depends on prepared objects (e.g., PreparedRequest), construct them via the owning class’s public methods (e.g., Session.prepare_request) or the object’s own preparation methods (e.g., PreparedRequest.prepare_cookies).


4. Output rules:
- Do not include Markdown code fences (```), output raw Python files only.
- Do NOT output any text outside the delimiters.
- Every delimiter block must be a complete standalone python file.


5. Quality target:
- Focus on a single case per generated test file. 
- Prefer tests that improve branch/line coverage of {{FUNCTION_NAME}}.
- Use good security hygiene. 


Now generate multiple UNIQUE test files (each file = exactly one test function, exactly one scenario) for {{FUNCTION_NAME}}. 
Validate the hard constraints internally before you output. 


